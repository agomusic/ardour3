// Generated by gtkmmproc -- DO NOT MODIFY!


#include <libgnomecanvasmm/canvas.h>
#include <libgnomecanvasmm/private/canvas_p.h>

// -*- C++ -*-
/* $Id$ */

/* canvas.cc
 *
 * Copyright (C) 1998 EMC Capital Management Inc.
 * Developed by Havoc Pennington <hp@pobox.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtk/gtk.h>

#include <libgnomecanvasmm/group.h>
#include <libgnomecanvasmm/item.h>
#include <libgnomecanvasmm/wrap_init.h>
#include <libgnomecanvas/gnome-canvas-util.h>

namespace Gnome
{

namespace Canvas
{

bool
Canvas::get_color(const Glib::ustring& spec, Gdk::Color& color) const
{
  GdkColor* pColor = 0;
  gboolean result = gnome_canvas_get_color(const_cast<GnomeCanvas*>(gobj()),
                                           const_cast<gchar*>(spec.c_str()),
                                           pColor);
  color = Glib::wrap(pColor);
  return (result == TRUE);
}


CanvasAA::CanvasAA()
:
  Glib::ObjectBase(0), //Mark this class as gtkmmproc-generated, rather than a custom class, to allow vfunc optimisations.
  Canvas(Glib::ConstructParams(canvas_class_.init(), "aa", TRUE, (char*) 0))
{
  //Note that the use of Glib::ConstructParams() here required use of _GMMPROC_PROTECTED_GCLASS in cavas.hg.
  
  //gtk_widget_push_colormap (gdk_rgb_get_cmap ());
  //ObjectBase::initialize ((GObject*)g_object_new (get_type (),
  //                                                "aa", true,
  //                                                NULL));
  //gtk_widget_pop_colormap();
}

CanvasAA::~CanvasAA()
{
}

Art::AffineTrans Canvas::w2c_affine() const
{
  double pAffine[6];
  gnome_canvas_w2c_affine(const_cast<GnomeCanvas*>(gobj()), pAffine);

  return Art::AffineTrans(pAffine);
}

} /* namespace Canvas */
} /* namespace Gnome */

namespace
{

static void Canvas_signal_draw_background_callback(GnomeCanvas* self, GdkDrawable* p0,gint p1,gint p2,gint p3,gint p4,void* data)
{
  using namespace Gnome::Canvas;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::Drawable>&,int,int,int,int > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
, p1
, p2
, p3
, p4
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo Canvas_signal_draw_background_info =
{
  "draw_background",
  (GCallback) &Canvas_signal_draw_background_callback,
  (GCallback) &Canvas_signal_draw_background_callback
};


static void Canvas_signal_render_background_callback(GnomeCanvas* self, GnomeCanvasBuf* p0,void* data)
{
  using namespace Gnome::Canvas;
  typedef sigc::slot< void,GnomeCanvasBuf* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
}

static const Glib::SignalProxyInfo Canvas_signal_render_background_info =
{
  "render_background",
  (GCallback) &Canvas_signal_render_background_callback,
  (GCallback) &Canvas_signal_render_background_callback
};

} // anonymous namespace


namespace Glib
{

Gnome::Canvas::Canvas* wrap(GnomeCanvas* object, bool take_copy)
{
  return dynamic_cast<Gnome::Canvas::Canvas *> (Glib::wrap_auto ((GObject*)(object), take_copy));
}

} /* namespace Glib */

namespace Gnome
{

namespace Canvas
{


/* The *_Class implementation: */

const Glib::Class& Canvas_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Canvas_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gnome_canvas_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:
  }

  return *this;
}

void Canvas_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

#ifdef GLIBMM_VFUNCS_ENABLED
  klass->request_update = &request_update_vfunc_callback;
#endif //GLIBMM_VFUNCS_ENABLED
  klass->draw_background = &draw_background_callback;
  klass->render_background = &render_background_callback;
}

#ifdef GLIBMM_VFUNCS_ENABLED
void Canvas_Class::request_update_vfunc_callback(GnomeCanvas* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      // Call the virtual member method, which derived classes might override.
      obj->request_update_vfunc();
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->request_update)
      (*base->request_update)(self);
  }
}

#endif //GLIBMM_VFUNCS_ENABLED

void Canvas_Class::draw_background_callback(GnomeCanvas* self, GdkDrawable* p0, gint p1, gint p2, gint p3, gint p4)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      // Call the virtual member method, which derived classes might override.
      obj->on_draw_background(Glib::wrap(p0, true)
, p1
, p2
, p3
, p4
);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->draw_background)
      (*base->draw_background)(self, p0, p1, p2, p3, p4);
  }
}

void Canvas_Class::render_background_callback(GnomeCanvas* self, GnomeCanvasBuf* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
      // Call the virtual member method, which derived classes might override.
      obj->on_render_background(p0);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->render_background)
      (*base->render_background)(self, p0);
  }
}


Glib::ObjectBase* Canvas_Class::wrap_new(GObject* o)
{
  return manage(new Canvas((GnomeCanvas*)(o)));

}


/* The implementation: */

Canvas::Canvas(const Glib::ConstructParams& construct_params)
:
  Gtk::Layout(construct_params)
{
  }

Canvas::Canvas(GnomeCanvas* castitem)
:
  Gtk::Layout((GtkLayout*)(castitem))
{
  }

Canvas::~Canvas()
{
  destroy_();
}

Canvas::CppClassType Canvas::canvas_class_; // initialize static member

GType Canvas::get_type()
{
  return canvas_class_.init().get_type();
}

GType Canvas::get_base_type()
{
  return gnome_canvas_get_type();
}


Canvas::Canvas()
:
  Glib::ObjectBase(0), //Mark this class as gtkmmproc-generated, rather than a custom class, to allow vfunc optimisations.
  Gtk::Layout(Glib::ConstructParams(canvas_class_.init()))
{
  }

Group* Canvas::root() const
{
  return Glib::wrap(gnome_canvas_root(const_cast<GnomeCanvas*>(gobj())));
}

void Canvas::set_scroll_region(double x1, double y1, double x2, double y2)
{
gnome_canvas_set_scroll_region(gobj(), x1, y1, x2, y2); 
}

void Canvas::get_scroll_region(double& x1, double& y1, double& x2, double& y2) const
{
gnome_canvas_get_scroll_region(const_cast<GnomeCanvas*>(gobj()), &(x1), &(y1), &(x2), &(y2)); 
}

void Canvas::set_center_scroll_region(bool center)
{
gnome_canvas_set_center_scroll_region(gobj(), static_cast<int>(center)); 
}

bool Canvas::get_center_scroll_region() const
{
  return gnome_canvas_get_center_scroll_region(const_cast<GnomeCanvas*>(gobj()));
}

void Canvas::set_pixels_per_unit(double n)
{
gnome_canvas_set_pixels_per_unit(gobj(), n); 
}

void Canvas::scroll_to(int x, int y)
{
gnome_canvas_scroll_to(gobj(), x, y); 
}

void Canvas::get_scroll_offsets(int& cx, int& cy) const
{
gnome_canvas_get_scroll_offsets(const_cast<GnomeCanvas*>(gobj()), &cx, &cy); 
}

void Canvas::update_now()
{
gnome_canvas_update_now(gobj()); 
}

Item* Canvas::get_item_at(double x, double y) const
{
  return Glib::wrap(gnome_canvas_get_item_at(const_cast<GnomeCanvas*>(gobj()), x, y));
}

void Canvas::request_redraw(int x1, int y1, int x2, int y2)
{
gnome_canvas_request_redraw(gobj(), x1, y1, x2, y2); 
}

void Canvas::request_redraw(ArtUta* uta)
{
gnome_canvas_request_redraw_uta(gobj(), uta); 
}

void Canvas::w2c(double wx, double wy, int& cx, int& cy) const
{
gnome_canvas_w2c(const_cast<GnomeCanvas*>(gobj()), wx, wy, &cx, &cy); 
}

void Canvas::w2c(double wx, double wy, double& cx, double& cy) const
{
gnome_canvas_w2c_d(const_cast<GnomeCanvas*>(gobj()), wx, wy, &(cx), &(cy)); 
}

void Canvas::c2w(int cx, int cy, double& wx, double& wy) const
{
gnome_canvas_c2w(const_cast<GnomeCanvas*>(gobj()), cx, cy, &(wx), &(wy)); 
}

void Canvas::window_to_world(double winx, double winy, double& worldx, double& worldy) const
{
gnome_canvas_window_to_world(const_cast<GnomeCanvas*>(gobj()), winx, winy, &(worldx), &(worldy)); 
}

void Canvas::world_to_window(double worldx, double worldy, double& winx, double& winy) const
{
gnome_canvas_world_to_window(const_cast<GnomeCanvas*>(gobj()), worldx, worldy, &(winx), &(winy)); 
}

gulong Canvas::get_color_pixel(guint rgba) const
{
  return gnome_canvas_get_color_pixel(const_cast<GnomeCanvas*>(gobj()), rgba);
}

void Canvas::set_stipple_origin(const Glib::RefPtr<Gdk::GC>& gc)
{
gnome_canvas_set_stipple_origin(gobj(), Glib::unwrap(gc)); 
}

void Canvas::set_dither(Gdk::RgbDither dither)
{
gnome_canvas_set_dither(gobj(), ((GdkRgbDither)(dither))); 
}

Gdk::RgbDither Canvas::get_dither() const
{
  return ((Gdk::RgbDither)(gnome_canvas_get_dither(const_cast<GnomeCanvas*>(gobj()))));
}

void Canvas::update_svp(ArtSVP** p_svp, ArtSVP* new_svp)
{
gnome_canvas_update_svp(gobj(), p_svp, new_svp); 
}

void Canvas::update_svp_clip(ArtSVP** p_svp, ArtSVP* new_svp, ArtSVP* clip_svp)
{
gnome_canvas_update_svp_clip(gobj(), p_svp, new_svp, clip_svp); 
}

 double Canvas::get_pixels_per_unit() const
{
  return gobj()->pixels_per_unit;
}
 

Glib::SignalProxy5< void,const Glib::RefPtr<Gdk::Drawable>&,int,int,int,int > Canvas::signal_draw_background()
{
  return Glib::SignalProxy5< void,const Glib::RefPtr<Gdk::Drawable>&,int,int,int,int >(this, &Canvas_signal_draw_background_info);
}

Glib::SignalProxy1< void,GnomeCanvasBuf* > Canvas::signal_render_background()
{
  return Glib::SignalProxy1< void,GnomeCanvasBuf* >(this, &Canvas_signal_render_background_info);
}


#ifdef GLIBMM_PROPERTIES_ENABLED
Glib::PropertyProxy_ReadOnly<bool> Canvas::property_aa() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "aa");
}
#endif //GLIBMM_PROPERTIES_ENABLED


void Gnome::Canvas::Canvas::on_draw_background(const Glib::RefPtr<Gdk::Drawable>& drawable, int x, int y, int width, int height)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->draw_background)
    (*base->draw_background)(gobj(),Glib::unwrap(drawable),x,y,width,height);
}

void Gnome::Canvas::Canvas::on_render_background(GnomeCanvasBuf* buf)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->render_background)
    (*base->render_background)(gobj(),buf);
}


#ifdef GLIBMM_VFUNCS_ENABLED
void Gnome::Canvas::Canvas::request_update_vfunc() 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->request_update)
    (*base->request_update)(gobj());
}

#endif //GLIBMM_VFUNCS_ENABLED


} // namespace Canvas

} // namespace Gnome


