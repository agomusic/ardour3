// Generated by gtkmmproc -- DO NOT MODIFY!

#include <libgnomecanvasmm/line.h>
#include <libgnomecanvasmm/private/line_p.h>

/* $Id$ */

/* line.ccg
 *
 * Copyright (C) 1998 EMC Capital Management Inc.
 * Developed by Havoc Pennington <hp@pobox.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

//#include <libgnomecanvasmm/group.h>

namespace Gnome
{

namespace Canvas
{

Points::Points(size_type nbpoints)
: std::vector<Art::Point>(nbpoints), points_(0), owned_(false)
{}

Points::Points(GnomeCanvasPoints *castitem)
: points_(castitem),owned_(false)
{
  while (size() < points_->num_points) {
       push_back (Art::Point());
  }

  //GnomeCanvasPoints has an array of doubles, used 2 at a time:
  int i = 0;
  for(iterator it = begin(); i < points_->num_points; i += 2, ++it)
  {
    (*it).set_x(points_->coords[i]);
    (*it).set_y(points_->coords[i+1]);
  }
}

Points::~Points()
{
  if (owned_ && points_)
    gnome_canvas_points_free(points_);
}

Points::operator bool() const
{
  return (!is_null());
}

bool Points::is_null() const
{
  return size() == 0;
}

GnomeCanvasPoints* Points::_gobj() const
{
  int i = 0;
  
  if(!points_)
  {
    points_ = gnome_canvas_points_new(size());
    owned_ = true;
  }
  else if(size() != static_cast<unsigned int>(points_->num_points))
  {
    if (owned_)
     gnome_canvas_points_free(points_);

    points_ = gnome_canvas_points_new(size());
    owned_ = true;
  }
  
  for(const_iterator it = begin(); it != end(); ++it, i+=2)
  {
    points_->coords[i] = (*it).get_x();
    points_->coords[i+1] = (*it).get_y();
  }

  return points_;
}


Line::Line(Group& parentx)
  : Item(GNOME_CANVAS_ITEM(g_object_new(get_type(),0)))
{
  item_construct(parentx);
}

Line::Line(Group& parentx, const Points& points)
  : Item(GNOME_CANVAS_ITEM(g_object_new(get_type(),0)))
{
  item_construct(parentx);
  property_points().set_value(points);
}

} /* namespace Canvas */
} /* namespace Gnome */


// static
GType Glib::Value<Gnome::Canvas::Points>::value_type()
{
  return Gnome::Canvas::Points::get_type();
}


namespace
{
} // anonymous namespace


namespace Glib
{

Gnome::Canvas::Line* wrap(GnomeCanvasLine* object, bool take_copy)
{
  return dynamic_cast<Gnome::Canvas::Line *> (Glib::wrap_auto ((GObject*)(object), take_copy));
}

} /* namespace Glib */

namespace Gnome
{

namespace Canvas
{


/* The *_Class implementation: */

const Glib::Class& Line_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Line_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gnome_canvas_line_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:
  }

  return *this;
}

void Line_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

}


Glib::ObjectBase* Line_Class::wrap_new(GObject* o)
{
  return manage(new Line((GnomeCanvasLine*)(o)));

}


/* The implementation: */

Line::Line(const Glib::ConstructParams& construct_params)
:
  Item(construct_params)
{
  }

Line::Line(GnomeCanvasLine* castitem)
:
  Item((GnomeCanvasItem*)(castitem))
{
  }

Line::~Line()
{
  destroy_();
}

Line::CppClassType Line::line_class_; // initialize static member

GType Line::get_type()
{
  return line_class_.init().get_type();
}

GType Line::get_base_type()
{
  return gnome_canvas_line_get_type();
}


Glib::PropertyProxy<Points> Line::property_points() 
{
  return Glib::PropertyProxy<Points>(this, "points");
}

Glib::PropertyProxy_ReadOnly<Points> Line::property_points() const
{
  return Glib::PropertyProxy_ReadOnly<Points>(this, "points");
}

Glib::PropertyProxy<Glib::ustring> Line::property_fill_color() 
{
  return Glib::PropertyProxy<Glib::ustring>(this, "fill-color");
}

Glib::PropertyProxy_ReadOnly<Glib::ustring> Line::property_fill_color() const
{
  return Glib::PropertyProxy_ReadOnly<Glib::ustring>(this, "fill-color");
}

Glib::PropertyProxy<Gdk::Color> Line::property_fill_color_gdk() 
{
  return Glib::PropertyProxy<Gdk::Color>(this, "fill-color-gdk");
}

Glib::PropertyProxy_ReadOnly<Gdk::Color> Line::property_fill_color_gdk() const
{
  return Glib::PropertyProxy_ReadOnly<Gdk::Color>(this, "fill-color-gdk");
}

Glib::PropertyProxy<guint> Line::property_fill_color_rgba() 
{
  return Glib::PropertyProxy<guint>(this, "fill-color-rgba");
}

Glib::PropertyProxy_ReadOnly<guint> Line::property_fill_color_rgba() const
{
  return Glib::PropertyProxy_ReadOnly<guint>(this, "fill-color-rgba");
}

Glib::PropertyProxy< Glib::RefPtr<Gdk::Bitmap> > Line::property_fill_stipple() 
{
  return Glib::PropertyProxy< Glib::RefPtr<Gdk::Bitmap> >(this, "fill-stipple");
}

Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Bitmap> > Line::property_fill_stipple() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gdk::Bitmap> >(this, "fill-stipple");
}

Glib::PropertyProxy<guint> Line::property_width_pixels() 
{
  return Glib::PropertyProxy<guint>(this, "width-pixels");
}

Glib::PropertyProxy_ReadOnly<guint> Line::property_width_pixels() const
{
  return Glib::PropertyProxy_ReadOnly<guint>(this, "width-pixels");
}

Glib::PropertyProxy<double> Line::property_width_units() 
{
  return Glib::PropertyProxy<double>(this, "width-units");
}

Glib::PropertyProxy_ReadOnly<double> Line::property_width_units() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "width-units");
}

Glib::PropertyProxy<Gdk::CapStyle> Line::property_cap_style() 
{
  return Glib::PropertyProxy<Gdk::CapStyle>(this, "cap-style");
}

Glib::PropertyProxy_ReadOnly<Gdk::CapStyle> Line::property_cap_style() const
{
  return Glib::PropertyProxy_ReadOnly<Gdk::CapStyle>(this, "cap-style");
}

Glib::PropertyProxy<Gdk::JoinStyle> Line::property_join_style() 
{
  return Glib::PropertyProxy<Gdk::JoinStyle>(this, "join-style");
}

Glib::PropertyProxy_ReadOnly<Gdk::JoinStyle> Line::property_join_style() const
{
  return Glib::PropertyProxy_ReadOnly<Gdk::JoinStyle>(this, "join-style");
}

Glib::PropertyProxy<Gdk::LineStyle> Line::property_line_style() 
{
  return Glib::PropertyProxy<Gdk::LineStyle>(this, "line-style");
}

Glib::PropertyProxy_ReadOnly<Gdk::LineStyle> Line::property_line_style() const
{
  return Glib::PropertyProxy_ReadOnly<Gdk::LineStyle>(this, "line-style");
}

Glib::PropertyProxy<bool> Line::property_first_arrowhead() 
{
  return Glib::PropertyProxy<bool>(this, "first-arrowhead");
}

Glib::PropertyProxy_ReadOnly<bool> Line::property_first_arrowhead() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "first-arrowhead");
}

Glib::PropertyProxy<bool> Line::property_last_arrowhead() 
{
  return Glib::PropertyProxy<bool>(this, "last-arrowhead");
}

Glib::PropertyProxy_ReadOnly<bool> Line::property_last_arrowhead() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "last-arrowhead");
}

Glib::PropertyProxy<bool> Line::property_smooth() 
{
  return Glib::PropertyProxy<bool>(this, "smooth");
}

Glib::PropertyProxy_ReadOnly<bool> Line::property_smooth() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "smooth");
}

Glib::PropertyProxy<guint> Line::property_spline_steps() 
{
  return Glib::PropertyProxy<guint>(this, "spline-steps");
}

Glib::PropertyProxy_ReadOnly<guint> Line::property_spline_steps() const
{
  return Glib::PropertyProxy_ReadOnly<guint>(this, "spline-steps");
}

Glib::PropertyProxy<double> Line::property_arrow_shape_a() 
{
  return Glib::PropertyProxy<double>(this, "arrow-shape-a");
}

Glib::PropertyProxy_ReadOnly<double> Line::property_arrow_shape_a() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "arrow-shape-a");
}

Glib::PropertyProxy<double> Line::property_arrow_shape_b() 
{
  return Glib::PropertyProxy<double>(this, "arrow-shape-b");
}

Glib::PropertyProxy_ReadOnly<double> Line::property_arrow_shape_b() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "arrow-shape-b");
}

Glib::PropertyProxy<double> Line::property_arrow_shape_c() 
{
  return Glib::PropertyProxy<double>(this, "arrow-shape-c");
}

Glib::PropertyProxy_ReadOnly<double> Line::property_arrow_shape_c() const
{
  return Glib::PropertyProxy_ReadOnly<double>(this, "arrow-shape-c");
}


} // namespace Canvas

} // namespace Gnome


