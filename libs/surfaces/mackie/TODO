* how long can UI signal callbacks take to execute? What happens if they block?
  where ENSURE_CORRECT_THREAD is a macro that is modelled on ENSURE_GUI_THREAD
  if the handler is not called in the "correct thread", it will use a pseudo-RT-safe-enough technique to get the correct thread to recall "handler" later on, and return.
  
* occasional hang on startup. deadlock?
* finish button mapping
* discuss button mapping for Ardour
* concurrency for bank switching? And make sure "old" events aren't sent to "new" faders
* concurrency in write( bytes ). Queueing?
* Are remote_ids supposed to be 1-based or 0-based?
* TODOs in code
* handle remote_control_id changed signal from Route.
* handle removal of route. Need another session signal?
* Some indication on the UI of remote_ids?
  Useful for surfaces that don't have a scribble strip.
* use i18n. see string_compose
* MackieControlProtocol in namespace Mackie?
* Generic surface code to common location
* power-cycling of surface. fd_midiport doesn't close.
* remove couts
* jog with transport rolling doesn't work properly

Later
-----
* which bank switching - overlap or dead faders? Option?
* signals for buttons?

Actual Mackie
-------------
* docs claim that unit will send a host query on init.
* test Mackie surface object. Apparently led rings don't work
* timecode & 55 char displays
* midi bandwidth

Bugs
----

* get_state isn't called on deactivate
* close existing and load other session doesn't start control surface
* set_state is called twice from the control_manager
* routes "forget" their remote_id between session save and the next session load
* definitely something wrong with remote_id assignment on session create
  (master strip assigned 0).
* gui enables record for tracks with no inputs
