/* $Id: widget.hg,v 1.48 2006/09/19 20:08:42 murrayc Exp $ */

/* Copyright (C) 2002, 2003 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
#include <pangomm/context.h>
#include <pangomm/layout.h>

#include <gtkmmconfig.h> //For GTKMM_ATKMM_ENABLED
#ifdef GTKMM_ATKMM_ENABLED
#include <atkmm/object.h>
#include <atkmm/implementor.h>
#endif //GTKMM_ATKMM_ENABLED

#include <gdkmm/event.h>
#include <gdkmm/types.h>
#include <gdkmm/window.h>
#include <gdkmm/dragcontext.h>
#include <gdkmm/pixbuf.h>
#include <gdkmm/screen.h>
#include <gtkmm/enums.h>
#include <gdkmm/display.h>
//#include <gtkmm/style.h>
#include <gtkmm/targetlist.h>
#include <gtkmm/rc.h>
#include <gtkmm/object.h>
#include <gtkmm/clipboard.h>
//#include <gtkmm/action.h>

_DEFS(gtkmm,gtk)
_PINCLUDE(gtkmm/private/object_p.h)


#ifndef DOXYGEN_SHOULD_SKIP_THIS
extern "C"
{
typedef struct _GtkTargetEntry GtkTargetEntry;
}

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

namespace Gtk
{

_CC_INCLUDE(gtk/gtktypebuiltins.h)
_WRAP_ENUM(DestDefaults, GtkDestDefaults)
_WRAP_ENUM(WidgetFlags, GtkWidgetFlags)
_WRAP_ENUM(WidgetHelpType, GtkWidgetHelpType)

class Action;
class Style;
class AccelGroup;
class Adjustment;
class Window;
class Container;
class Settings;
class Tooltip;

typedef GtkRequisition Requisition;

// Gtk::Allocation is a typedef of Gdk::Rectangle because GtkAllocation is
// a typedef of GdkRectangle.
typedef Gdk::Rectangle Allocation;



/** @defgroup Widgets Widgets
 */

/** Abstract Widget (Base class for all widgets)
 *
 * As the base class of all widgets this contains all of the properties
 * and methods common to all widgets.  It is an abstract class that
 * can not be instantiated.
 *
 * Important part of widgets are the *_event signals and virtual methods
 * that every widget have. Those are events coming directly from gdk and
 * thus also from XLib. By overriding those virtual methods you can
 * trap everything a widget can ever do.
 * In order to capture events from a widget, the event mask must
 * first be set with ().
 *
 * Only widgets with a Gdk::Window on the server side are allowed to
 * capture events.  Widgets in the Gtk::Misc group for example lack
 * a Gdk::Window.
 */
class Widget
: public Object
#ifdef GTKMM_ATKMM_ENABLED
  ,public Atk::Implementor
#endif //GTKMM_ATKMM_ENABLED
{
  _CLASS_GTKOBJECT(Widget,GtkWidget,GTK_WIDGET,Gtk::Object,GtkObject)
  _IMPLEMENTS_INTERFACE(Atk::Implementor, ifdef GTKMM_ATKMM_ENABLED)
  _IGNORE(gtk_widget_set, gtk_widget_queue_clear, gtk_widget_queue_clear_area, gtk_widget_draw,
          gtk_widget_set_uposition, gtk_widget_set_usize, gtk_widget_set_visual, gtk_widget_push_visual,
          gtk_widget_pop_visual, gtk_widget_set_default_visual, gtk_widget_set_rc_style, gtk_widget_restore_default_style)
  _IGNORE(gtk_widget_destroy, gtk_widget_ref, gtk_widget_unref, gtk_widget_destroyed, gtk_widget_hide_on_delete,
          gtk_widget_style_get_valist, gtk_widget_list_accel_closures, gtk_widget_style_get)
public:
  friend class Main;
  _CUSTOM_DTOR

  _WRAP_METHOD(bool set_scroll_adjustments(Adjustment& hadjustment, Adjustment& vadjustment), gtk_widget_set_scroll_adjustments)

  _WRAP_METHOD(void show(), gtk_widget_show)
  _WRAP_METHOD(void show_now(), gtk_widget_show_now)
  _WRAP_METHOD(void hide(), gtk_widget_hide)

  _WRAP_METHOD(void show_all(), gtk_widget_show_all)

  _WRAP_METHOD(void hide_all(), gtk_widget_hide_all)


/* QUEUE DRAWS */

  _WRAP_METHOD(void queue_draw(), gtk_widget_queue_draw)
  _WRAP_METHOD(void queue_draw_area(int x, int y, int width, int height), gtk_widget_queue_draw_area)
  _WRAP_METHOD(void queue_resize(), gtk_widget_queue_resize)

  /** This function is typically used when implementing a Gtk::Container
   * subclass.  Obtains the preferred size of a widget. The container
   * uses this information to arrange its child widgets and decide what
   * size allocations to give them with size_allocate().
   * 
   * You can also call this function from an application, with some
   * caveats. Most notably, getting a size request requires the widget
   * to be associated with a screen, because font information may be
   * needed. Multihead-aware applications should keep this in mind.
   * 
   * Also remember that the size request is not necessarily the size
   * a widget will actually be allocated.
   * 
   * See also get_child_requisition().
   * @result A Gtk::Requisition.
   */
  Requisition size_request() const;
  _IGNORE(gtk_widget_size_request)

  _WRAP_METHOD(void size_request(const Requisition& requisition), gtk_widget_size_request, deprecated "Use size_request() const.")

  _WRAP_METHOD(void size_allocate(const Allocation& allocation), gtk_widget_size_allocate)


  _WRAP_METHOD(void add_accelerator(const Glib::ustring& accel_signal, const Glib::RefPtr<AccelGroup>& accel_group,
               guint accel_key, Gdk::ModifierType accel_mods, AccelFlags accel_flags), gtk_widget_add_accelerator)

  _WRAP_METHOD(bool remove_accelerator(const Glib::RefPtr<AccelGroup>& accel_group,
               guint accel_key, Gdk::ModifierType accel_mods), gtk_widget_remove_accelerator)
  _WRAP_METHOD(void set_accel_path(const Glib::ustring& accel_path,
                                   const Glib::RefPtr<AccelGroup>& accel_group),
               gtk_widget_set_accel_path)

  //GList* gtk_widget_list_accel_closures();

  //TODO: Or maybe it is useless: gboolean gtk_widget_can_activate_accel(GtkWidget *widget, guint signal_id)
  
  _WRAP_METHOD(bool mnemonic_activate(bool group_cycling), gtk_widget_mnemonic_activate)

  //TODO: Use C++ type
  _WRAP_METHOD(bool event(GdkEvent* event), gtk_widget_event)
  _WRAP_METHOD(int send_expose(GdkEvent* event), gtk_widget_send_expose)
  _WRAP_METHOD(bool activate(), gtk_widget_activate)

  _WRAP_METHOD(void reparent(Widget & new_parent), gtk_widget_reparent)

  bool intersect(const Gdk::Rectangle& area) const;
  _WRAP_METHOD(bool intersect(const Gdk::Rectangle& area, Gdk::Rectangle& intersection) const, gtk_widget_intersect)

  _WRAP_METHOD(Gdk::Region region_intersect(const Gdk::Region& region) const, gtk_widget_region_intersect)

  _WRAP_METHOD(void freeze_child_notify(), gtk_widget_freeze_child_notify)
  _WRAP_METHOD(void	child_notify(const Glib::ustring& child_property), gtk_widget_child_notify)
  _WRAP_METHOD(void	thaw_child_notify(), gtk_widget_thaw_child_notify)

  _WRAP_METHOD(bool is_focus() const, gtk_widget_is_focus)
  _WRAP_METHOD(void	grab_focus(), gtk_widget_grab_focus)
  _WRAP_METHOD(void	grab_default(), gtk_widget_grab_default)

  /** Block events to everything else than this widget and its children. This
   * way you can get modal behaviour (usually not recommended). One practical
   * example could be when implementing a key-binding widget that needs
   * exclusive access to the key combination that the user presses next.
   *
   * Calls to add_modal_grab should be paired with calls to remove_modal_grab.
   */
  void add_modal_grab();

  /** Remove the modal grab of the widget in case it was previously grabbed.
   */
  void remove_modal_grab();

  /** Retrieve the widget which is currently grabbing all events.
   */
  static Widget* get_current_modal_grab();

  _WRAP_METHOD(void set_name(const Glib::ustring& name), gtk_widget_set_name)
  void unset_name();
  _WRAP_METHOD(Glib::ustring get_name() const, gtk_widget_get_name)

  _WRAP_METHOD(void set_state(Gtk::StateType state), gtk_widget_set_state)
  _WRAP_METHOD(void set_sensitive(bool sensitive = true), gtk_widget_set_sensitive)
  _WRAP_METHOD(void set_app_paintable(bool app_paintable = true), gtk_widget_set_app_paintable)
  _WRAP_METHOD(void set_double_buffered(bool double_buffered = true), gtk_widget_set_double_buffered)

  _WRAP_METHOD(void set_redraw_on_allocate(bool redraw_on_allocate = true),
               gtk_widget_set_redraw_on_allocate)

  _WRAP_METHOD(void set_child_visible(bool is_visible = true), gtk_widget_set_child_visible)
  _WRAP_METHOD(bool get_child_visible() const, gtk_widget_get_child_visible)

  _WRAP_METHOD(Container* get_parent(), gtk_widget_get_parent)
  _WRAP_METHOD(const Container* get_parent() const, gtk_widget_get_parent, constversion)

  _WRAP_METHOD(Glib::RefPtr<Gdk::Window> get_parent_window(), gtk_widget_get_parent_window, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Gdk::Window> get_parent_window() const, gtk_widget_get_parent_window, refreturn, constversion)
  _WRAP_METHOD(void set_parent_window(const Glib::RefPtr<const Gdk::Window>& parent_window), gtk_widget_set_parent_window)

  _WRAP_METHOD(bool child_focus(DirectionType direction), gtk_widget_child_focus)

  _WRAP_METHOD(bool keynav_failed(DirectionType direction), gtk_widget_keynav_failed)
  _WRAP_METHOD(void error_bell(), gtk_widget_error_bell)

  _WRAP_METHOD(void set_size_request(int width = -1, int  height = -1), gtk_widget_set_size_request)
  _WRAP_METHOD(void get_size_request(int& width, int& height) const, gtk_widget_get_size_request)

  _WRAP_METHOD(void set_events(Gdk::EventMask events), gtk_widget_set_events)
  _WRAP_METHOD(void add_events(Gdk::EventMask events), gtk_widget_add_events)
  _WRAP_METHOD(void set_extension_events(Gdk::ExtensionMode mode), gtk_widget_set_extension_events)

  _WRAP_METHOD(Gdk::ExtensionMode get_extension_events() const, gtk_widget_get_extension_events)

  _WRAP_METHOD(Container* get_toplevel(), gtk_widget_get_toplevel)
  _WRAP_METHOD(const Container* get_toplevel() const, gtk_widget_get_toplevel, constversion)

  _WRAP_METHOD(Widget* get_ancestor(GType widget_type), gtk_widget_get_ancestor)
  _WRAP_METHOD(const Widget* get_ancestor(GType widget_type) const, gtk_widget_get_ancestor, constversion)

  _WRAP_METHOD(Glib::RefPtr<Gdk::Colormap> get_colormap(), gtk_widget_get_colormap, refreturn)

  _WRAP_METHOD(Glib::RefPtr<Gdk::Visual> get_visual(), gtk_widget_get_visual, refreturn)

  _WRAP_METHOD(Glib::RefPtr<Gdk::Screen> get_screen(), gtk_widget_get_screen, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Gdk::Screen> get_screen() const, gtk_widget_get_screen, refreturn, constversion)

  _WRAP_METHOD(bool has_screen() const, gtk_widget_has_screen)

  _WRAP_METHOD(Glib::RefPtr<Gdk::Display> get_display(), gtk_widget_get_display, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Gdk::Display> get_display() const, gtk_widget_get_display, refreturn, constversion)

  _WRAP_METHOD(Glib::RefPtr<Gdk::Window> get_root_window(), gtk_widget_get_root_window, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Gdk::Window> get_root_window() const, gtk_widget_get_root_window, refreturn, constversion)
  
  _WRAP_METHOD(Glib::RefPtr<Settings> get_settings(), gtk_widget_get_settings, refreturn)

  _WRAP_METHOD(Glib::RefPtr<Clipboard> get_clipboard(const Glib::ustring& selection), gtk_widget_get_clipboard, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Clipboard> get_clipboard(const Glib::ustring& selection) const, gtk_widget_get_clipboard, refreturn, constversion)

  //TODO: This probably needs a special conversion to do an extra ref (take_copy=true) for the returned instance:
  _WRAP_METHOD(Glib::RefPtr<Atk::Object> get_accessible(), gtk_widget_get_accessible, refreturn, ifdef GTKMM_ATKMM_ENABLED)

  _WRAP_METHOD(void set_colormap(const Glib::RefPtr<const Gdk::Colormap> &colormap), gtk_widget_set_colormap)
  _WRAP_METHOD(Gdk::EventMask get_events() const, gtk_widget_get_events)
  _WRAP_METHOD(void get_pointer(int &x, int &y) const, gtk_widget_get_pointer)
  _WRAP_METHOD(bool is_ancestor(Widget &ancestor) const, gtk_widget_is_ancestor)

  _WRAP_METHOD(bool translate_coordinates(Widget& dest_widget,
					       int src_x, int src_y,
					       int& dest_x, int& dest_y), gtk_widget_translate_coordinates)

/* STYLE */
  _WRAP_METHOD(void set_style(const Glib::RefPtr<Style>& style), gtk_widget_set_style)
  void unset_style();

  _WRAP_METHOD(void ensure_style(), gtk_widget_ensure_style)
  _WRAP_METHOD(Glib::RefPtr<Style> get_style(), gtk_widget_get_style, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Style> get_style() const, gtk_widget_get_style, refreturn, constversion)
  _WRAP_METHOD(void modify_style(const Glib::RefPtr<RcStyle>& style), gtk_widget_modify_style)
  _WRAP_METHOD(Glib::RefPtr<RcStyle> get_modifier_style(), gtk_widget_get_modifier_style, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const RcStyle> get_modifier_style() const, gtk_widget_get_modifier_style, refreturn, constversion)

  // we need custom documentation because modify_* can take a NULL pointer
  // (which we wrap with unset_*)
  /** Sets the foreground color for a widget in a particular state.
   * All other style values are left untouched. See also modify_style() and
   * unset_fg().
   *
   * @param state The state for which to set the foreground color.
   * @param color The color to assign (does not need to be allocated).
   */
  _WRAP_METHOD(void modify_fg(StateType state, const Gdk::Color& color), gtk_widget_modify_fg)


  /** Sets the background color for a widget in a particular state.
   * All other style values are left untouched. See also modify_style() and
   * unset_bg().
   *
   * @param state The state for which to set the background color.
   * @param color The color to assign (does not need to be allocated).
   */
  _WRAP_METHOD(void modify_bg(StateType state, const Gdk::Color& color), gtk_widget_modify_bg)

  // TODO: Document this, and perhaps add unset_bg_pixmap
  void modify_bg_pixmap(StateType state, const Glib::ustring& pixmap_name);

  /** Sets the text color for a widget in a particular state.
   * All other style values are left untouched. The text color is the
   * foreground color used along with the base color (see modify_base() ) for
   * widgets such as Gtk::Entry and Gtk::TextView. See also modify_style() and
   * unset_text().
   *
   * @param state The state for which to set the text color.
   * @param color The color to assign (does not need to be allocated).
   */
  _WRAP_METHOD(void modify_text(StateType state, const Gdk::Color& color), gtk_widget_modify_text)

  /** Sets the base color for a widget in a particular state.
   * All other style values are left untouched. The base color is the
   * background color used along with the text color (see modify_text() ) for
   * widgets such as Gtk::Entry and Gtk::TextView. See also modify_style() and
   * unset_base().
   *
   * @param state The state for which to set the text color.
   * @param color The color to assign (does not need to be allocated).
   */
  _WRAP_METHOD(void modify_base(StateType state, const Gdk::Color& color), gtk_widget_modify_base)

  /** Sets the cursor color to use in a widget, overriding the
   * cursor_color and secondary_cursor_color
   * style properties. All other style values are left untouched. 
   * See also modify_style().
   * See also unset_cursor().
   *
   * @param primary the color to use for primary cursor (does not need to be allocated).
   * @param secondary the color to use for secondary cursor (does not need to be allocated).
   *
   * @newin2p12
   */
  _WRAP_METHOD(void modify_cursor(const Gdk::Color& primary, const Gdk::Color& secondary), gtk_widget_modify_cursor)
  
  /// See modify_cursor().
  void unset_cursor();

  /** Sets the font to use for a widget.
   * All other style values are left untouched. See also modify_style() and
   * unset_font().
   */
  _WRAP_METHOD(void modify_font(const Pango::FontDescription& font_desc), gtk_widget_modify_font)

  /** Undo the effect of previous calls to modify_fg() for a particular state.
   * All other style values are left untouched. See also modify_style().
   */
  void unset_fg(StateType state);
  
  /** Undo the effect of previous calls to modify_bg() for a particular state.
   * All other style values are left untouched. See also modify_style().
   */
  void unset_bg(StateType state);

  /** Undo the effect of previous calls to modify_text() for a particular state.
   * All other style values are left untouched. See also modify_style().
   */
  void unset_text(StateType state);

  /** Undo the effect of previous calls to modify_base() for a particular state.
   * All other style values are left untouched. See also modify_style().
   */
  void unset_base(StateType state);

  /** Undo the effect of previous calls to modify_font() for a particular state.
   * All other style values are left untouched. See also modify_style().
   */
  void unset_font();

  //The parameter name is "the_property_name" to avoid a warning because there is a method with the "property_name" name.
  template <class PropertyType>
  void get_style_property(const Glib::ustring& the_property_name, PropertyType& value) const;

  _WRAP_METHOD(Glib::RefPtr<Pango::Context> create_pango_context(), gtk_widget_create_pango_context)
  _WRAP_METHOD(Glib::RefPtr<Pango::Context> get_pango_context(), gtk_widget_get_pango_context, refreturn)
  _WRAP_METHOD(Glib::RefPtr<Pango::Layout> create_pango_layout(const Glib::ustring& text), gtk_widget_create_pango_layout)

  _WRAP_METHOD(Glib::RefPtr<Gdk::Pixbuf> render_icon(const StockID& stock_id, IconSize size, const Glib::ustring& detail = Glib::ustring()), gtk_widget_render_icon)

  _WRAP_METHOD(void set_composite_name(const Glib::ustring& name), gtk_widget_set_composite_name)
  void unset_composite_name();
  _WRAP_METHOD(Glib::ustring get_composite_name() const, gtk_widget_get_composite_name)

  _WRAP_METHOD(void reset_rc_styles(),gtk_widget_reset_rc_styles)


  // PUSH/POP - these are used to create widgets.  Hidden arguments to override the defaults.
  _WRAP_METHOD(static void push_colormap(const Glib::RefPtr<const Gdk::Colormap>& cmap), gtk_widget_push_colormap)
  _WRAP_METHOD(static void pop_colormap(), gtk_widget_pop_colormap)

  _WRAP_METHOD(static void push_composite_child(), gtk_widget_push_composite_child)
  _WRAP_METHOD(static void pop_composite_child(), gtk_widget_pop_composite_child)


/* DEFAULTS */

  _WRAP_METHOD(static void set_default_colormap(const Glib::RefPtr<const Gdk::Colormap>& colormap), gtk_widget_set_default_colormap)
  _WRAP_METHOD(static Glib::RefPtr<Style> get_default_style(), gtk_widget_get_default_style, refreturn)
  _WRAP_METHOD(static Glib::RefPtr<Gdk::Colormap> get_default_colormap(), gtk_widget_get_default_colormap, refreturn)
  _WRAP_METHOD(static Glib::RefPtr<Gdk::Visual> get_default_visual(), gtk_widget_get_default_visual, refreturn)


/* Directionality of Text */

  _WRAP_METHOD(void set_direction(TextDirection dir), gtk_widget_set_direction)
  _WRAP_METHOD(TextDirection get_direction(), gtk_widget_get_direction)
  _WRAP_METHOD(static void set_default_direction(TextDirection dir), gtk_widget_set_default_direction)
  _WRAP_METHOD(static TextDirection get_default_direction(), gtk_widget_get_default_direction)


/* Shape masking */
  _WRAP_METHOD(void shape_combine_mask(const Glib::RefPtr<const Gdk::Bitmap>& shape_mask, int offset_x, int offset_y), gtk_widget_shape_combine_mask)
  void unset_shape_combine_mask();
  _WRAP_METHOD(void input_shape_combine_mask(const Glib::RefPtr<const Gdk::Bitmap>& shape_mask, int offset_x, int offset_y), gtk_widget_input_shape_combine_mask)
  void unset_input_shape_combine_mask();


  // must be realized 
  _WRAP_METHOD(void reset_shapes(),gtk_widget_reset_shapes)

/* Paths */
  /// Compute a widget's path of the form "GtkWindow.MyLabel"
  void path(Glib::ustring& path, Glib::ustring& path_reversed);
  void class_path(Glib::ustring& path, Glib::ustring& path_reversed);
  _IGNORE(gtk_widget_path, gtk_widget_class_path)

 _WRAP_METHOD(Glib::ListHandle<Widget*> list_mnemonic_labels(), gtk_widget_list_mnemonic_labels)
 _WRAP_METHOD(Glib::ListHandle<const Widget*> list_mnemonic_labels() const, gtk_widget_list_mnemonic_labels)
 _WRAP_METHOD(void add_mnemonic_label(Widget& label), gtk_widget_add_mnemonic_label)
 _WRAP_METHOD(void remove_mnemonic_label(Widget& label), gtk_widget_remove_mnemonic_label)
           

  //TODO: Should drag_get_data() be const?
  _WRAP_METHOD(void drag_get_data(const Glib::RefPtr<Gdk::DragContext>& context, Glib::ustring& target, guint32 time), gtk_drag_get_data)		
  _WRAP_METHOD(void drag_highlight(), gtk_drag_highlight)
  _WRAP_METHOD(void drag_unhighlight(), gtk_drag_unhighlight)

  void drag_dest_set(DestDefaults flags = DestDefaults(0), Gdk::DragAction actions = Gdk::DragAction(0));
  void drag_dest_set(const ArrayHandle_TargetEntry& targets, DestDefaults flags = DEST_DEFAULT_ALL, Gdk::DragAction actions = Gdk::ACTION_COPY);
  _IGNORE(gtk_drag_dest_set)

  _WRAP_METHOD(void drag_dest_set_proxy(const Glib::RefPtr<Gdk::Window>& proxy_window, Gdk::DragProtocol protocol, bool use_coordinates), gtk_drag_dest_set_proxy)
  _WRAP_METHOD(void drag_dest_unset(), gtk_drag_dest_unset)
  _WRAP_METHOD(Glib::ustring drag_dest_find_target(const Glib::RefPtr<Gdk::DragContext>& context, const Glib::RefPtr<TargetList>& target_list) const, gtk_drag_dest_find_target)
  Glib::ustring drag_dest_find_target(const Glib::RefPtr<Gdk::DragContext>& context) const;

  _WRAP_METHOD(Glib::RefPtr<TargetList> drag_dest_get_target_list(), gtk_drag_dest_get_target_list, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const TargetList> drag_dest_get_target_list() const, gtk_drag_dest_get_target_list, refreturn, constversion)
  _WRAP_METHOD(void drag_dest_set_target_list(const Glib::RefPtr<TargetList>& target_list), gtk_drag_dest_set_target_list)

  _WRAP_METHOD(void drag_dest_add_text_targets(), gtk_drag_dest_add_text_targets)  
  _WRAP_METHOD(void drag_dest_add_image_targets(), gtk_drag_dest_add_image_targets)
  _WRAP_METHOD(void drag_dest_add_uri_targets(), gtk_drag_dest_add_uri_targets)
 
  void drag_source_set(const ArrayHandle_TargetEntry& targets, Gdk::ModifierType start_button_mask = Gdk::MODIFIER_MASK, Gdk::DragAction actions = Gdk::ACTION_COPY);
  _IGNORE(gtk_drag_source_set)

  _WRAP_METHOD(void drag_source_unset(), gtk_drag_source_unset)

  _WRAP_METHOD(void drag_source_set_icon(const Glib::RefPtr<Gdk::Colormap>& colormap, const Glib::RefPtr<Gdk::Pixmap>& pixmap, const Glib::RefPtr<Gdk::Bitmap>& mask), gtk_drag_source_set_icon)
  _WRAP_METHOD(void drag_source_set_icon(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf), gtk_drag_source_set_icon_pixbuf)
  _WRAP_METHOD(void drag_source_set_icon(const StockID& stock_id), gtk_drag_source_set_icon_stock)
  _WRAP_METHOD(void drag_source_set_icon(const Glib::ustring& icon_name), gtk_drag_source_set_icon_name)

  _WRAP_METHOD(void drag_source_add_text_targets(), gtk_drag_source_add_text_targets)
  _WRAP_METHOD(void drag_source_add_uri_targets(), gtk_drag_source_add_uri_targets)
  _WRAP_METHOD(void drag_source_add_image_targets(), gtk_drag_source_add_image_targets)
  
  _WRAP_METHOD(Glib::RefPtr<Gdk::DragContext> drag_begin(const Glib::RefPtr<TargetList>& targets, Gdk::DragAction actions, int button, GdkEvent* event), gtk_drag_begin, refreturn)
  _WRAP_METHOD(bool drag_check_threshold(int start_x, int start_y, int current_x, int current_y), gtk_drag_check_threshold)
  _IGNORE(_gtk_drag_source_handle_event, _gtk_drag_dest_handle_event)

  //These should be a method of Gdk::DragContext, but gdkmm can't depend on gtkmm.
  static Widget* drag_get_source_widget(const Glib::RefPtr<Gdk::DragContext>& context);
  void drag_set_as_icon(const Glib::RefPtr<Gdk::DragContext>& context, int hot_x, int hot_y);
  
  

  _WRAP_METHOD(void queue_resize_no_redraw(), gtk_widget_queue_resize_no_redraw)
  _WRAP_METHOD(bool get_no_show_all() const, gtk_widget_get_no_show_all)
  _WRAP_METHOD(void set_no_show_all(bool no_show_all = true), gtk_widget_set_no_show_all)

  //Used when implementing containers:
  _WRAP_METHOD(void set_parent(Widget& parent), gtk_widget_set_parent)
  _WRAP_METHOD(void unparent(), gtk_widget_unparent)

  //TODO: When exactly do we need to custom containers need to call map() on the child widgets?
  //Most containers that derive from GtkContainer do not need to, but GtkNotebook does.
  _WRAP_METHOD(void map(), gtk_widget_map)
  _WRAP_METHOD(void unmap(), gtk_widget_unmap)

  //TODO: The drawable should be passed by reference, when we can break API/ABI, but it's not the end of the world. murrayc.
  void draw_insertion_cursor(Glib::RefPtr<Gdk::Drawable> drawable, const Gdk::Rectangle& area, const Gdk::Rectangle& location, bool is_primary, TextDirection direction, bool draw_arrow = true);
  _IGNORE(gtk_draw_insertion_cursor)

  // Gtk+ 2.12 tooltip API
  _WRAP_METHOD(void set_tooltip_window(Window& widget), gtk_widget_set_tooltip_window)
  _WRAP_METHOD(Window* get_tooltip_window(), gtk_widget_get_tooltip_window)
  _WRAP_METHOD(void trigger_tooltip_query(), gtk_widget_trigger_tooltip_query)
  _WRAP_METHOD(void set_tooltip_text(const Glib::ustring& text), gtk_widget_set_tooltip_text)
  _WRAP_METHOD(Glib::ustring get_tooltip_text() const, gtk_widget_get_tooltip_text)
  _WRAP_METHOD(void set_tooltip_markup(const Glib::ustring& markup), gtk_widget_set_tooltip_markup)
  _WRAP_METHOD(Glib::ustring get_tooltip_markup() const, gtk_widget_get_tooltip_markup)
  _WRAP_METHOD(void set_has_tooltip(bool has_tooltip = TRUE), gtk_widget_set_has_tooltip)
  _WRAP_METHOD(bool get_has_tooltip() const, gtk_widget_get_has_tooltip)
  
  /* FLAGS */

  //: Returns property {flags.toplevel}.
  bool is_toplevel() const;

  //: Returns property {flags.nowindow}.
  bool has_no_window() const;

  //: Returns property {flags.realized}.
  bool is_realized() const;

  //: Returns property {flags.mapped}.
  bool is_mapped() const;

  //: Returns property {flags.visible}.
  bool is_visible() const; 

  //: Returns if the widget is ready to be drawn to.
  // Checks to see if the widget is both visible and mapped which
  // makes it possible to perform drawing commands on.
  bool is_drawable() const;
  
  //: Returns property {flags.sensitive}. You might want to check
  // is_sensitive instead.
  bool sensitive() const;

  bool parent_sensitive() const;
  bool is_sensitive() const;
  bool can_focus() const;
  bool has_focus() const;
  bool can_default() const;
  bool has_default() const;
  bool has_grab() const;
  bool rc_style() const;
  bool is_composite_child() const;
  bool app_paintable() const;
  bool receives_default() const;
  bool double_buffered() const;

  WidgetFlags get_flags() const;
  void set_flags(WidgetFlags flags);
  void unset_flags(WidgetFlags flags);

  int get_width() const;
  int get_height() const;

  _WRAP_METHOD(bool is_composited() const, gtk_widget_is_composited)

  //From gtkaction.h:
  _WRAP_METHOD(Glib::RefPtr<Action> get_action(), gtk_widget_get_action, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Action> get_action() const, gtk_widget_get_action, refreturn, constversion)

  _MEMBER_GET(state, state, Gtk::StateType, guint8)
  _MEMBER_GET(saved_state, saved_state, Gtk::StateType, guint8)
  _MEMBER_GET(requisition, requisition, Requisition, GtkRequisition)
  _MEMBER_GET(allocation, allocation, Allocation, GtkAllocation)
  _MEMBER_GET_GOBJECT(window, window, Gdk::Window, GdkWindow*)


  _WRAP_SIGNAL(void show(),"show")
  _WRAP_SIGNAL(void hide(),"hide")

  //: Emitted on mapping of a widget to the screen.
  //- See {flags.mapped}.
  _WRAP_SIGNAL(void map(),"map")

  //- See {flags.mapped}.
  _WRAP_SIGNAL(void unmap(),"unmap")

  //: Emitted on realization of a widget.
  //- See {flags.realized}.  This is also responsible for
  //- setting {flags.realized} when it is done.  Therefore, 
  //- when overriding the impl method, you should call the 
  //- default realize method.
  _WRAP_SIGNAL(void realize(),"realize")

  //- See {flags.realized}.  This should not be called by the user.
  //_WRAP(meth|sig|impl,void unrealize_(),gtk_widget_unrealize,"unrealize")
  _WRAP_SIGNAL(void unrealize(),"unrealize")

  _WRAP_SIGNAL(void size_request(Requisition* requisition), "size_request")
  _WRAP_SIGNAL(void size_allocate(Allocation& allocation), "size_allocate")

// Changed signals -- inform widget of internal changes.
// We rename parent_set => parent_changed 
//  and      style_set  => style_changed 
//  to avoid confusion with set_parent and set_style.

  _WRAP_SIGNAL(void state_changed(Gtk::StateType previous_state), "state_changed")

  //: Informs objects that their parent changed.
  //- The widget passed is the former parent, which may be 0 if 
  //- there was no parent. (was parent_set in GTK+)
  _WRAP_SIGNAL(void parent_changed(Widget* previous_parent), "parent_set")

  _WRAP_SIGNAL(void hierarchy_changed(Widget* previous_toplevel), "hierarchy_changed")

//Note: We use Gtk::Style instead of Style here, to fix a build problem on MacOS X 
//that we don't fully understand. See bug #493057.
#m4 _CONVERSION(`GtkStyle*',`const Glib::RefPtr<Gtk::Style>&',`Glib::wrap($3, true)')
#m4 _CONVERSION(`const Glib::RefPtr<Gtk::Style>&',`GtkStyle*',__CONVERT_REFPTR_TO_P)
  /** The style-set signal is emitted when a new style has been set 
   * on a widget. Note that style-modifying functions like 
   * modify_base() also cause this signal to be emitted.
   *
   * @param previous_style  the previous style, or an empty RefPtr if the widget 
   * just got its initial style. 
   */
  _WRAP_SIGNAL(void style_changed(const Glib::RefPtr<Gtk::Style>& previous_style), "style_set")

  _WRAP_SIGNAL(void direction_changed(TextDirection direction), "direction_changed")

  _WRAP_SIGNAL(void grab_notify(bool was_grabbed), "grab_notify")

 /** The ::child-notify signal is emitted for each child property that has 
  * changed on an object. The signal's detail holds the property name. 
  *
  * @param pspec The GParamSpec of the changed child property.
  */
  _WRAP_SIGNAL(void child_notify(GParamSpec* pspec), "child_notify")

  //_WRAP_SIGNAL(void add_accelerator(guint, GtkAccelGroup*, guint accel_key, Gdk::ModifierType, AccelFlags), "add-accelerator")
  //_WRAP_SIGNAL(void remove_accelerator(GtkAccelGroup* accel_group, guint, Gdk::ModifierType), "remove-accelerator")
  _WRAP_SIGNAL(bool mnemonic_activate(bool group_cycling), "mnemonic_activate")
  _WRAP_SIGNAL(void grab_focus(), "grab_focus")
  _WRAP_SIGNAL(bool focus(DirectionType direction), "focus")
  _WRAP_SIGNAL(bool event(GdkEvent* event), "event")
  _WRAP_SIGNAL(void event_after(GdkEvent* event), "event_after", no_default_handler)

  //: Event triggered by user pressing button.
  _WRAP_SIGNAL(bool button_press_event(GdkEventButton* event),"button_press_event")

  //: Event triggered by user releasing button.
  _WRAP_SIGNAL(bool button_release_event(GdkEventButton* event), "button_release_event")

  _WRAP_SIGNAL(bool scroll_event(GdkEventScroll* event), "scroll_event")

  //: Event triggered by user moving pointer.
  _WRAP_SIGNAL(bool motion_notify_event(GdkEventMotion* event), "motion_notify_event")

 /** The delete_event signal is emitted if a user requests that
  * a toplevel window is closed. The default handler for this signal
  * hides the window.
  *
  * @param event the event which triggered this signal.
  * @result true to stop other handlers from being invoked for the event, 
  * or false to propagate the event. further.
  */
  _WRAP_SIGNAL(bool delete_event(GdkEventAny* event), "delete_event")

#m4begin
dnl// Hook in special code to catch explicit uses of gtk_object_destroy() by
dnl// GTK+ code, e.g. when receiving the GDK_DELETE event.  For details, look
dnl// at Gtk::Widget_Class::dispose_vfunc_callback() in widget.ccg.
dnl
  _PUSH(SECTION_PCC_CLASS_INIT_VFUNCS)
#endif //GLIBMM_VFUNCS_ENABLED //We always need dispose_vfunc_callback
    reinterpret_cast<GObjectClass*>(klass)->dispose = &dispose_vfunc_callback;
#ifdef GLIBMM_VFUNCS_ENABLED
  _SECTION(SECTION_PH_VFUNCS)
#endif //GLIBMM_VFUNCS_ENABLED //We always need dispose_vfunc_callback
    static void dispose_vfunc_callback(GObject* self);
#ifdef GLIBMM_VFUNCS_ENABLED
  _POP()
#m4end

  //: Event triggered by window requiring a refresh.
  //- Expose events cover a rectangular area that was covered
  //- or obscured by another window.  That area is now exposed
  //- and thus is needs to be redrawn.  
  //-
  //- If the application is not capable of redrawing sections
  //- it should watch the count field and only draw on the last
  //- even indicated.  This is important for things such as 
  //- Gtk::DrawingArea. 
  _WRAP_SIGNAL(bool expose_event(GdkEventExpose* event), "expose_event")

  //: Event triggered by a key press will widget has focus.
  _WRAP_SIGNAL(bool key_press_event(GdkEventKey* event), "key_press_event")

  //: Event triggered by a key release will widget has focus.
  _WRAP_SIGNAL(bool key_release_event(GdkEventKey* event), "key_release_event")

  //: Event triggered by pointer entering widget area.
  _WRAP_SIGNAL(bool enter_notify_event(GdkEventCrossing* event), "enter_notify_event")

  //: Event triggered by pointer leaving widget area.
  _WRAP_SIGNAL(bool leave_notify_event(GdkEventCrossing* event), "leave_notify_event")
 
  //: Event triggered by a window resizing.
  _WRAP_SIGNAL(bool configure_event(GdkEventConfigure* event), "configure_event")
  _WRAP_SIGNAL(bool focus_in_event(GdkEventFocus* event), "focus_in_event")
  _WRAP_SIGNAL(bool focus_out_event(GdkEventFocus* event), "focus_out_event")
  _WRAP_SIGNAL(bool map_event(GdkEventAny* event), "map_event")
  _WRAP_SIGNAL(bool unmap_event(GdkEventAny* event), "unmap_event")
  _WRAP_SIGNAL(bool property_notify_event(GdkEventProperty* event), "property_notify_event")
  _WRAP_SIGNAL(bool selection_clear_event(GdkEventSelection* event), "selection_clear_event")
  _WRAP_SIGNAL(bool selection_request_event(GdkEventSelection* event), "selection_request_event")
  _WRAP_SIGNAL(bool selection_notify_event(GdkEventSelection* event), "selection_notify_event")
  _WRAP_SIGNAL(bool proximity_in_event(GdkEventProximity* event), "proximity_in_event")
  _WRAP_SIGNAL(bool proximity_out_event(GdkEventProximity* event), "proximity_out_event")
  _WRAP_SIGNAL(bool visibility_notify_event(GdkEventVisibility* event), "visibility_notify_event")
  _WRAP_SIGNAL(bool client_event(GdkEventClient* event), "client_event")
  _WRAP_SIGNAL(bool no_expose_event(GdkEventAny* event), "no_expose_event")
  _WRAP_SIGNAL(bool window_state_event(GdkEventWindowState* event), "window_state_event")

  //We use the optional custom_c_callback parameter with _WRAP_SIGNAL() for some of these,
  //so that we can write special code to wrap the non-const SelectionData& output parameters:
  _WRAP_SIGNAL(void selection_get(SelectionData& selection_data, guint info, guint time), "selection_get", custom_c_callback)
  _WRAP_SIGNAL(void selection_received(const SelectionData& selection_data, guint time), "selection_received")
  
#m4 _CONVERSION(`GdkDragContext*',`const Glib::RefPtr<Gdk::DragContext>&',Glib::wrap($3, true))

  /** The drag_begin signal is emitted on the drag source when a drag is started. 
   * A typical reason to connect to this signal is to set up a custom drag icon with
   * drag_source_set_icon().
   *
   * @param context the drag context
   */
  _WRAP_SIGNAL(void drag_begin(const Glib::RefPtr<Gdk::DragContext>& context), "drag_begin")
  
  /** The drag_end signal is emitted on the drag source when a drag is finished. 
   * A typical reason to connect to this signal is to undo things done in the drag-begin 
   * signal handler.
   *
   * @param context the drag context.
   */
  _WRAP_SIGNAL(void drag_end(const Glib::RefPtr<Gdk::DragContext>& context), "drag_end")

  /** The drag_data_get signal is emitted on the drag source when the drop site requests
   * the data which is dragged. It is the responsibility of the signal handler to fill @a data
   * with the data in the format which is indicated by @a info. See SelectionData::set() and 
   * SelectionData::set_text().
   *
   * @param context: the drag context.
   * @param selection_data the SelectionData to be filled with the dragged data.
   * @param info the info that has been registered with the target in the TargetList.
   * @param time the timestamp at which the data was requested.
   */
  _WRAP_SIGNAL(void drag_data_get(const Glib::RefPtr<Gdk::DragContext>& context, SelectionData& selection_data, guint info, guint time), "drag_data_get", custom_c_callback)
  
  /**  The drag_data_delete signal is emitted on the drag source when a drag with the action
   * Gdk::ACTION_MOVE is successfully completed. The signal handler is responsible for deleting
   * the data that has been dropped. What "delete" means, depends on the context of the drag
   * operation. 
   *
   * @param context the drag context.
   */
  _WRAP_SIGNAL(void drag_data_delete(const Glib::RefPtr<Gdk::DragContext>& context), "drag_data_delete")

  //TODO: Check the parameters: _WRAP_SIGNAL(bool drag_failed(const Glib::RefPtr<Gdk::DragContext>& context), "drag_failed")
  
  /**  The drag_leave signal is emitted on the drop site when the cursor leaves the widget.
   * A typical reason to connect to this signal is to undo things done in the drag_motion signal handler, 
   *  e.g. undo highlighting with drag_unhighlight().
   *
   * @param context the drag context.
   * @param time the timestamp of the motion event.
   */
  _WRAP_SIGNAL(void drag_leave(const Glib::RefPtr<Gdk::DragContext>& context, guint time), "drag_leave")
  
  /** The drag_motion signal is emitted on the drop site when the user moves the cursor over
   * the widget during a drag. The signal handler must determine whether the cursor position is in 
   * a drop zone or not. If it is not in a drop zone, it returns false and no further processing is
   * necessary. Otherwise, the handler returns true. In this case, the handler is responsible for
   * providing the necessary information for displaying feedback to the user, by calling
   * drag_status(). If the decision whether the drop will be accepted or rejected can't be made
   * based solely on the cursor position and the type of the data, the handler may inspect the dragged 
   * data by calling drag_get_data() and defer the drag_status() call to the drag_data_received 
   * handler. 
   *
   * Note that there is no drag_enter signal. The drag receiver has to keep track of whether
   * he has received any drag_motion signals since the last drag_leave and if not, treat the
   * drag_motion signal as an "enter" signal. Upon an "enter", the handler will typically highlight 
   * the drop site with drag_highlight().
   * 
   * @param context the drag context.
   * @param x the x coordinate of the current cursor position.
   * @param y the y coordinate of the current cursor position.
   * @param time the timestamp of the motion event.
   * @result whether the cursor position is in a drop zone.
   */
  _WRAP_SIGNAL(bool drag_motion(const Glib::RefPtr<Gdk::DragContext>& context, int x, int y, guint time), "drag_motion")
  
  /** The drag_drop signal is emitted on the drop site when the user drops the data
   * onto the widget. The signal handler must determine whether the cursor position is in 
   * a drop zone or not. If it is not in a drop zone, it returns false and no further 
   * processing is necessary. Otherwise, the handler returns true. In this case, the handler 
   * must ensure that gtk_drag_finish() is called to let the source know that the drop is done.
   * The call to gtk_drag_finish() can be done either directly or in a drag_data_received handler
   * which gets triggered by calling drop_get_data() to receive the data for one or more of the 
   * supported targets.
   *
   * @param context the drag context.
   * @param x the x coordinate of the current cursor position.
   * @param y the y coordinate of the current cursor position.
   * @param time: the timestamp of the motion event.
   * @result whether the cursor position is in a drop zone
   */
  _WRAP_SIGNAL(bool drag_drop(const Glib::RefPtr<Gdk::DragContext>& context, int x, int y, guint time), "drag_drop")
  
  
  /** The drag_data_received signal is emitted on the drop site when the dragged data has been 
   * received. If the data was received in order to determine whether the drop will be accepted, 
   * the handler is expected to call drag_status() and <emphasis>not</emphasis> finish the drag. 
   * If the data was received in response to a drag_drop signal (and this is the last target to be 
   * received), the handler for this signal is expected to process the received data and then call 
   * drag_finish(), setting the @a success parameter depending on whether the data was processed 
   * successfully.
   *
   * The handler may inspect and modify @drag_context->action before calling gtk_drag_finish(), 
   * e.g. to implement %Gdk::ACTION_ASK.
   *
   * @param drag_context the drag context
   * @param x where the drop happened
   * @param y where the drop happened
   * @param data the received data
   * @param info the info that has been registered with the target in the TargetList.
   * @param time the timestamp at which the data was received.
   */
  _WRAP_SIGNAL(void drag_data_received(const Glib::RefPtr<Gdk::DragContext>& context, int x, int y, const SelectionData& selection_data, guint info, guint time), "drag_data_received")

  //Note that the deprecated keyword has no effect on _WRAP_SIGNAL() yet.
  //It doesn't seem like a good idea to put virtual functions in #ifdefs, because that would change the size of the class instances.
  /** @deprecated This should never have been in the API. It was never meaningful.
   */
  _WRAP_SIGNAL(Glib::RefPtr<Atk::Object> get_accessible(), "get_accessible", ifdef GTKMM_ATKMM_ENABLED, refreturn, deprecated)
  
  _WRAP_SIGNAL(void screen_changed(const Glib::RefPtr<Gdk::Screen>& previous_screen), "screen_changed")

  _WRAP_SIGNAL(void composited_changed(), "composited_changed", no_default_handler)

//TODO: The signal_id is very C-like here:                                                                          
  //_WRAP_SIGNAL(bool can_activate_accel(guint signal_id), "can_activate_accel")
  
  //Keybinding signals:
  _IGNORE_SIGNAL("popup_menu") //TODO: This might actually be useful. See the C docs.
  _IGNORE_SIGNAL("show_help")
  _IGNORE_SIGNAL("keynav_failed")

  _IGNORE_SIGNAL("destroy-event")

  // Tooltip signal
  _WRAP_SIGNAL(bool query_tooltip(int x, int y, bool keyboard_tooltip, const Glib::RefPtr<Tooltip>& tooltip), "query_tooltip", no_default_handler)

  //TODO: Wrap this (added in GTK+ 2.8 but forgotten): _WRAP_SIGNAL(bool grab_broken_event(GdkEventGrabBroken* event), "grab_broken_event", no_default_handler)

  _WRAP_PROPERTY("name", Glib::ustring)
  _WRAP_PROPERTY("parent", Container*)
  _WRAP_PROPERTY("width_request", int)
  _WRAP_PROPERTY("height_request", int)
  _WRAP_PROPERTY("visible", bool)
  _WRAP_PROPERTY("sensitive", bool)
  _WRAP_PROPERTY("app_paintable", bool)
  _WRAP_PROPERTY("can_focus", bool)
  _WRAP_PROPERTY("has_focus", bool)
  _WRAP_PROPERTY("can_default", bool)
  _WRAP_PROPERTY("has_default", bool)
  _WRAP_PROPERTY("receives_default", bool)
  _WRAP_PROPERTY("composite_child", bool)
  _WRAP_PROPERTY("style", Glib::RefPtr<Style>)
  _WRAP_PROPERTY("events", Gdk::EventMask)
  _WRAP_PROPERTY("extension_events", Gdk::ExtensionMode)
  _WRAP_PROPERTY("has_tooltip", bool)
  _WRAP_PROPERTY("tooltip_markup", Glib::ustring)
  _WRAP_PROPERTY("tooltip_text", Glib::ustring)

protected:
  //comment in GTK+ header: "seldomly overidden"
  _WRAP_VFUNC(void dispatch_child_properties_changed(guint, GParamSpec**), "dispatch_child_properties_changed")

  _WRAP_VFUNC(void show_all(), "show_all")
  _WRAP_VFUNC(void hide_all(), "hide_all")

  _WRAP_VFUNC(Glib::RefPtr<Atk::Object> get_accessible(), "get_accessible", refreturn, ifdef GTKMM_ATKMM_ENABLED)

protected:
  _CTOR_DEFAULT()

  _WRAP_METHOD(void realize(), gtk_widget_realize)
  _WRAP_METHOD(void unrealize(), gtk_widget_unrealize)

  _WRAP_METHOD(void get_child_requisition(Requisition& requisition) const, gtk_widget_get_child_requisition)

  //The parameter name is "the_property_name" to avoid a warning because there is a method with the "property_name" name.
  _WRAP_METHOD(void get_style_property_value(
                   const Glib::ustring& the_property_name, Glib::ValueBase& value) const,
               gtk_widget_style_get_property)

  void realize_if_needed();

  _MEMBER_SET(allocation, allocation, Allocation, GtkAllocation)
  _MEMBER_SET_GOBJECT(window, window, Gdk::Window, GdkWindow*)

#m4begin
dnl// Hook in custom hierarchy_changed callback.
dnl// It will use the generated callback.
dnl
  _PUSH(SECTION_PCC_CLASS_INIT_DEFAULT_SIGNAL_HANDLERS)
    klass->hierarchy_changed = &hierarchy_changed_callback_custom;
  _SECTION(SECTION_PH_DEFAULT_SIGNAL_HANDLERS)
    static void hierarchy_changed_callback_custom(GtkWidget* self, GtkWidget* p0);
  _POP()
#m4end

#m4begin
dnl// Hook in custom hierarchy_changed callback.
dnl// It will use the generated callback.
dnl
  _PUSH(SECTION_PCC_CLASS_INIT_DEFAULT_SIGNAL_HANDLERS)
    klass->parent_set = &parent_set_callback_custom;
  _SECTION(SECTION_PH_DEFAULT_SIGNAL_HANDLERS)
    static void parent_set_callback_custom(GtkWidget* self, GtkWidget* p0);
  _POP()
#m4end

};


#ifndef DOXYGEN_SHOULD_SKIP_THIS

//The parameter name is "the_property_name" to avoid a warning because there is a method with the "property_name" name.
template <class PropertyType>
void Widget::get_style_property(const Glib::ustring& the_property_name, PropertyType& value) const
{
  Glib::Value<PropertyType> property_value;
  property_value.init(Glib::Value<PropertyType>::value_type());

  this->get_style_property_value(the_property_name, property_value);

  value = property_value.get();
}

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

} // namespace Gtk

