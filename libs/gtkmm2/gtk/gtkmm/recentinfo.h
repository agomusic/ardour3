// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GTKMM_RECENTINFO_H
#define _GTKMM_RECENTINFO_H


#include <glibmm.h>

/* Copyright (C) 2006 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gdkmm/pixbuf.h>

#include <time.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
typedef struct _GtkRecentInfo GtkRecentInfo;
#endif //DOXYGEN_SHOULD_SKIP_THIS

namespace Gtk
{


/** Contains informations found when looking up an entry of the
 * recently used files list.
 *
 * @newin2p10
 *
 * @ingroup RecentFiles
 */
class RecentInfo
{
  public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  typedef RecentInfo CppObjectType;
  typedef GtkRecentInfo BaseObjectType;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


  // For use with Glib::RefPtr<> only.
  void reference()   const;
  void unreference() const;

  ///Provides access to the underlying C instance.
  GtkRecentInfo*       gobj();

  ///Provides access to the underlying C instance.
  const GtkRecentInfo* gobj() const;

  ///Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.
  GtkRecentInfo* gobj_copy() const;

protected:
  // Do not derive this.  Gtk::RecentInfo can neither be constructed nor deleted.
  RecentInfo();
  void operator delete(void*, size_t);

private:
  // noncopyable
  RecentInfo(const RecentInfo&);
  RecentInfo& operator=(const RecentInfo&);


public:

  bool equal(const RecentInfo& other) const;
  /// Tests whether the RecentInfo is valid.
  operator bool() const;

  
  Glib::ustring get_uri() const;
  
  Glib::ustring get_display_name() const;
  
  Glib::ustring get_description() const;
  
  Glib::ustring get_mime_type() const;
  
  
  time_t get_added() const;
  
  time_t get_modified() const;
  
  time_t get_visited() const;
  
  
  bool get_private_hint() const;

  
  bool get_application_info(const Glib::ustring& app_name, Glib::StringArrayHandle& app_exec, guint& count, time_t& time) const;
  Glib::StringArrayHandle get_applications() const;
  
  //_WRAP_METHOD(Glib::StringArrayHandle get_applications(unsigned& length) const, gtk_recent_info_get_applications)
  
  Glib::ustring last_application() const;
  
  bool has_application(const Glib::ustring& app_name) const;
  
  Glib::StringArrayHandle get_groups() const;
  
  //_WRAP_METHOD(Glib::StringArrayHandle get_groups(unsigned& length) const, gtk_recent_info_get_groups)
  
  bool has_group(const Glib::ustring& group) const;
  
  
  Glib::RefPtr<Gdk::Pixbuf> get_icon(int size);
  
  Glib::RefPtr<const Gdk::Pixbuf> get_icon(int size) const;
  
  
  Glib::ustring get_short_name() const;
  
  Glib::ustring get_uri_display() const;
  
  
  int get_age() const;
  
  bool is_local() const;
  
  bool exists() const;

  
  //_WRAP_METHOD(bool match(const RecentInfo& b) const, gtk_recent_info_match)


};


#ifndef DOXYGEN_SHOULD_SKIP_THIS

struct RecentInfoTraits
{
  typedef Glib::RefPtr<RecentInfo> CppType;
  typedef const GtkRecentInfo* CType;
  typedef GtkRecentInfo* CTypeNonConst;

  static CType to_c_type(const CppType& obj) { return Glib::unwrap(obj); }
  static CType to_c_type(const CType& obj) { return obj; }
  static CppType to_cpp_type(const CType& obj); //Implemented in the .cpp file
  static void release_c_type(const CType& /* obj */) { /* gtk_recent_info_unref(const_cast<CTypeNonConst>(obj)); */}
};
#endif

//TODO: We normally put these inside the class:

/** @relates Gtk::RecentInfo */
inline bool operator==(const RecentInfo& lhs, const RecentInfo& rhs)
  { return lhs.equal(rhs); }

/** @relates Gtk::RecentInfo */
inline bool operator!=(const RecentInfo& lhs, const RecentInfo& rhs)
  { return !lhs.equal(rhs); }

} // namespace Gtk


namespace Glib
{

  /** @relates Gtk::RecentInfo
   * @param object The C instance
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   */
  Glib::RefPtr<Gtk::RecentInfo> wrap(GtkRecentInfo* object, bool take_copy = false);

} // namespace Glib


#endif /* _GTKMM_RECENTINFO_H */

